// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hand.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "hand.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace atheer {
class HandEventDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<HandEvent>
     _instance;
} _HandEvent_default_instance_;
class HandDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<Hand>
     _instance;
} _Hand_default_instance_;
class FingerDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<Finger>
     _instance;
} _Finger_default_instance_;
class Point3DDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<Point3D>
     _instance;
} _Point3D_default_instance_;

namespace protobuf_hand_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
};

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _HandEvent_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_HandEvent_default_instance_);_Hand_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_Hand_default_instance_);_Finger_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_Finger_default_instance_);_Point3D_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_Point3D_default_instance_);_Finger_default_instance_._instance.get_mutable()->tip_ = const_cast< ::atheer::Point3D*>(
      ::atheer::Point3D::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
namespace {
void AddDescriptorsImpl() {
  InitDefaults();
}
} // anonymous namespace

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}

}  // namespace protobuf_hand_2eproto


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HandEvent::kHandsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HandEvent::HandEvent()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hand_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atheer.HandEvent)
}
HandEvent::HandEvent(const HandEvent& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      hands_(from.hands_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:atheer.HandEvent)
}

void HandEvent::SharedCtor() {
  _cached_size_ = 0;
}

HandEvent::~HandEvent() {
  // @@protoc_insertion_point(destructor:atheer.HandEvent)
  SharedDtor();
}

void HandEvent::SharedDtor() {
}

void HandEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HandEvent& HandEvent::default_instance() {
  protobuf_hand_2eproto::InitDefaults();
  return *internal_default_instance();
}

HandEvent* HandEvent::New(::google::protobuf::Arena* arena) const {
  HandEvent* n = new HandEvent;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HandEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:atheer.HandEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hands_.Clear();
  _internal_metadata_.Clear();
}

bool HandEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atheer.HandEvent)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .atheer.Hand hands = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hands()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atheer.HandEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atheer.HandEvent)
  return false;
#undef DO_
}

void HandEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atheer.HandEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .atheer.Hand hands = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->hands_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->hands(static_cast<int>(i)), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:atheer.HandEvent)
}

size_t HandEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atheer.HandEvent)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // repeated .atheer.Hand hands = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->hands_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hands(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HandEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HandEvent*>(&from));
}

void HandEvent::MergeFrom(const HandEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atheer.HandEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  hands_.MergeFrom(from.hands_);
}

void HandEvent::CopyFrom(const HandEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atheer.HandEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandEvent::IsInitialized() const {
  return true;
}

void HandEvent::Swap(HandEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HandEvent::InternalSwap(HandEvent* other) {
  using std::swap;
  hands_.InternalSwap(&other->hands_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string HandEvent::GetTypeName() const {
  return "atheer.HandEvent";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HandEvent

// repeated .atheer.Hand hands = 1;
int HandEvent::hands_size() const {
  return hands_.size();
}
void HandEvent::clear_hands() {
  hands_.Clear();
}
const ::atheer::Hand& HandEvent::hands(int index) const {
  // @@protoc_insertion_point(field_get:atheer.HandEvent.hands)
  return hands_.Get(index);
}
::atheer::Hand* HandEvent::mutable_hands(int index) {
  // @@protoc_insertion_point(field_mutable:atheer.HandEvent.hands)
  return hands_.Mutable(index);
}
::atheer::Hand* HandEvent::add_hands() {
  // @@protoc_insertion_point(field_add:atheer.HandEvent.hands)
  return hands_.Add();
}
::google::protobuf::RepeatedPtrField< ::atheer::Hand >*
HandEvent::mutable_hands() {
  // @@protoc_insertion_point(field_mutable_list:atheer.HandEvent.hands)
  return &hands_;
}
const ::google::protobuf::RepeatedPtrField< ::atheer::Hand >&
HandEvent::hands() const {
  // @@protoc_insertion_point(field_list:atheer.HandEvent.hands)
  return hands_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Hand::kFingersFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Hand::Hand()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hand_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atheer.Hand)
}
Hand::Hand(const Hand& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      fingers_(from.fingers_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:atheer.Hand)
}

void Hand::SharedCtor() {
  _cached_size_ = 0;
}

Hand::~Hand() {
  // @@protoc_insertion_point(destructor:atheer.Hand)
  SharedDtor();
}

void Hand::SharedDtor() {
}

void Hand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Hand& Hand::default_instance() {
  protobuf_hand_2eproto::InitDefaults();
  return *internal_default_instance();
}

Hand* Hand::New(::google::protobuf::Arena* arena) const {
  Hand* n = new Hand;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Hand::Clear() {
// @@protoc_insertion_point(message_clear_start:atheer.Hand)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fingers_.Clear();
  _internal_metadata_.Clear();
}

bool Hand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atheer.Hand)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .atheer.Finger fingers = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fingers()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atheer.Hand)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atheer.Hand)
  return false;
#undef DO_
}

void Hand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atheer.Hand)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .atheer.Finger fingers = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->fingers_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->fingers(static_cast<int>(i)), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:atheer.Hand)
}

size_t Hand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atheer.Hand)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // repeated .atheer.Finger fingers = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->fingers_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fingers(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Hand::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Hand*>(&from));
}

void Hand::MergeFrom(const Hand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atheer.Hand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  fingers_.MergeFrom(from.fingers_);
}

void Hand::CopyFrom(const Hand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atheer.Hand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hand::IsInitialized() const {
  return true;
}

void Hand::Swap(Hand* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Hand::InternalSwap(Hand* other) {
  using std::swap;
  fingers_.InternalSwap(&other->fingers_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Hand::GetTypeName() const {
  return "atheer.Hand";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Hand

// repeated .atheer.Finger fingers = 2;
int Hand::fingers_size() const {
  return fingers_.size();
}
void Hand::clear_fingers() {
  fingers_.Clear();
}
const ::atheer::Finger& Hand::fingers(int index) const {
  // @@protoc_insertion_point(field_get:atheer.Hand.fingers)
  return fingers_.Get(index);
}
::atheer::Finger* Hand::mutable_fingers(int index) {
  // @@protoc_insertion_point(field_mutable:atheer.Hand.fingers)
  return fingers_.Mutable(index);
}
::atheer::Finger* Hand::add_fingers() {
  // @@protoc_insertion_point(field_add:atheer.Hand.fingers)
  return fingers_.Add();
}
::google::protobuf::RepeatedPtrField< ::atheer::Finger >*
Hand::mutable_fingers() {
  // @@protoc_insertion_point(field_mutable_list:atheer.Hand.fingers)
  return &fingers_;
}
const ::google::protobuf::RepeatedPtrField< ::atheer::Finger >&
Hand::fingers() const {
  // @@protoc_insertion_point(field_list:atheer.Hand.fingers)
  return fingers_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Finger::kIdFieldNumber;
const int Finger::kTipFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Finger::Finger()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hand_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atheer.Finger)
}
Finger::Finger(const Finger& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_tip()) {
    tip_ = new ::atheer::Point3D(*from.tip_);
  } else {
    tip_ = NULL;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:atheer.Finger)
}

void Finger::SharedCtor() {
  ::memset(&tip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&tip_)) + sizeof(id_));
  _cached_size_ = 0;
}

Finger::~Finger() {
  // @@protoc_insertion_point(destructor:atheer.Finger)
  SharedDtor();
}

void Finger::SharedDtor() {
  if (this != internal_default_instance()) delete tip_;
}

void Finger::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Finger& Finger::default_instance() {
  protobuf_hand_2eproto::InitDefaults();
  return *internal_default_instance();
}

Finger* Finger::New(::google::protobuf::Arena* arena) const {
  Finger* n = new Finger;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Finger::Clear() {
// @@protoc_insertion_point(message_clear_start:atheer.Finger)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && tip_ != NULL) {
    delete tip_;
  }
  tip_ = NULL;
  id_ = 0;
  _internal_metadata_.Clear();
}

bool Finger::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atheer.Finger)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .atheer.Point3D tip = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tip()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atheer.Finger)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atheer.Finger)
  return false;
#undef DO_
}

void Finger::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atheer.Finger)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // .atheer.Point3D tip = 2;
  if (this->has_tip()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->tip_, output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:atheer.Finger)
}

size_t Finger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atheer.Finger)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // .atheer.Point3D tip = 2;
  if (this->has_tip()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->tip_);
  }

  // int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Finger::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Finger*>(&from));
}

void Finger::MergeFrom(const Finger& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atheer.Finger)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_tip()) {
    mutable_tip()->::atheer::Point3D::MergeFrom(from.tip());
  }
  if (from.id() != 0) {
    set_id(from.id());
  }
}

void Finger::CopyFrom(const Finger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atheer.Finger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Finger::IsInitialized() const {
  return true;
}

void Finger::Swap(Finger* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Finger::InternalSwap(Finger* other) {
  using std::swap;
  swap(tip_, other->tip_);
  swap(id_, other->id_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Finger::GetTypeName() const {
  return "atheer.Finger";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Finger

// int32 id = 1;
void Finger::clear_id() {
  id_ = 0;
}
::google::protobuf::int32 Finger::id() const {
  // @@protoc_insertion_point(field_get:atheer.Finger.id)
  return id_;
}
void Finger::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:atheer.Finger.id)
}

// .atheer.Point3D tip = 2;
bool Finger::has_tip() const {
  return this != internal_default_instance() && tip_ != NULL;
}
void Finger::clear_tip() {
  if (GetArenaNoVirtual() == NULL && tip_ != NULL) delete tip_;
  tip_ = NULL;
}
const ::atheer::Point3D& Finger::tip() const {
  const ::atheer::Point3D* p = tip_;
  // @@protoc_insertion_point(field_get:atheer.Finger.tip)
  return p != NULL ? *p : *reinterpret_cast<const ::atheer::Point3D*>(
      &::atheer::_Point3D_default_instance_);
}
::atheer::Point3D* Finger::mutable_tip() {
  
  if (tip_ == NULL) {
    tip_ = new ::atheer::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:atheer.Finger.tip)
  return tip_;
}
::atheer::Point3D* Finger::release_tip() {
  // @@protoc_insertion_point(field_release:atheer.Finger.tip)
  
  ::atheer::Point3D* temp = tip_;
  tip_ = NULL;
  return temp;
}
void Finger::set_allocated_tip(::atheer::Point3D* tip) {
  delete tip_;
  tip_ = tip;
  if (tip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atheer.Finger.tip)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Point3D::kXFieldNumber;
const int Point3D::kYFieldNumber;
const int Point3D::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Point3D::Point3D()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hand_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:atheer.Point3D)
}
Point3D::Point3D(const Point3D& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:atheer.Point3D)
}

void Point3D::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
  _cached_size_ = 0;
}

Point3D::~Point3D() {
  // @@protoc_insertion_point(destructor:atheer.Point3D)
  SharedDtor();
}

void Point3D::SharedDtor() {
}

void Point3D::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Point3D& Point3D::default_instance() {
  protobuf_hand_2eproto::InitDefaults();
  return *internal_default_instance();
}

Point3D* Point3D::New(::google::protobuf::Arena* arena) const {
  Point3D* n = new Point3D;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Point3D::Clear() {
// @@protoc_insertion_point(message_clear_start:atheer.Point3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
  _internal_metadata_.Clear();
}

bool Point3D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:atheer.Point3D)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u /* 13 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:atheer.Point3D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:atheer.Point3D)
  return false;
#undef DO_
}

void Point3D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:atheer.Point3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // float z = 3;
  if (this->z() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:atheer.Point3D)
}

size_t Point3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:atheer.Point3D)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  if (this->z() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point3D::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Point3D*>(&from));
}

void Point3D::MergeFrom(const Point3D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:atheer.Point3D)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.z() != 0) {
    set_z(from.z());
  }
}

void Point3D::CopyFrom(const Point3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:atheer.Point3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point3D::IsInitialized() const {
  return true;
}

void Point3D::Swap(Point3D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Point3D::InternalSwap(Point3D* other) {
  using std::swap;
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Point3D::GetTypeName() const {
  return "atheer.Point3D";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Point3D

// float x = 1;
void Point3D::clear_x() {
  x_ = 0;
}
float Point3D::x() const {
  // @@protoc_insertion_point(field_get:atheer.Point3D.x)
  return x_;
}
void Point3D::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:atheer.Point3D.x)
}

// float y = 2;
void Point3D::clear_y() {
  y_ = 0;
}
float Point3D::y() const {
  // @@protoc_insertion_point(field_get:atheer.Point3D.y)
  return y_;
}
void Point3D::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:atheer.Point3D.y)
}

// float z = 3;
void Point3D::clear_z() {
  z_ = 0;
}
float Point3D::z() const {
  // @@protoc_insertion_point(field_get:atheer.Point3D.z)
  return z_;
}
void Point3D::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:atheer.Point3D.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace atheer

// @@protoc_insertion_point(global_scope)
